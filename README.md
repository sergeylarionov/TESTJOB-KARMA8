
# мыслительный процесс
- не использовать ООП.... Код может быть несовершенным и даже не 100% рабочим.... хм, а как же поддерживать приложение в дальнейшем и соблюдать принципы SOLID? Или может это по поводу реализации всяческих объектов для работы с БД и передачей данных внутри приложения? (DTO, Aggregate и прочие Domain Entity и VO) - ОК, сделаю прототип приложения в функциональном стиле
- самый тупой способ который может прийти на ум: пойти "в лоб" и добавить 2 поля с флагами отправлено/нет (notify_before_1_day, notify_before_3_day). Не будем его реализовывать, его сложно поддерживать и смешивать данные о юзерах и о отправке емейлов не SOLID'но. К тому же кол-во записей в БД намекает нам что проблемы с таким подходом начнутся уже сразу после деплоя в прод и чем дальше, тем больше.
- поэтому нам нужна очередь: будем использовать таблицу в БД для ее реализации и воркеры (на кроне) для работы с ней
- при обработке очереди на отправку нужно учесть что письмо может не отправиться, при этом очередь не должна быть заблокирована такими сообщениями. нужно предусмотреть механизм пропуска сообщений, которые невозможно отправить (то есть нужно поле с кол-вом неудачных отправок)
- также возможно сервис отправки может быть недоступен (в коде прототипа не буду это учитывать - есть разные варианты обработки этой ситуации)
- функции отправки и проверки емейлов: будем считать что они не выбрасывают исключения, а только дают положительный или отрицательный результат работы (сложности реализации скрыты)
- вообще во всем коде прототипа я буду считать что нигде внезапно не выскочит исключение (в реальности конечно не так)
- на счет ф-ии проверки емейлов check_email(). так как вызов этой ф-и дорогой и долгий, то вызывать ее будем только тогда, когда confirmed=0 (юзер не подтвердил свой емейл) и checked=0 (предположу что это связано с результатом работы ф-ии check_email() )
- поле в таблице с юзерами valid=0 - думаю это можно проверить регуляркой на этапе регистрации юзера в коде и хранить в БД это нет смысла
- скорее всего нам потребуется логгировать ошибки и суммарную статистику отправки - эмулирую это ф-ей logError()
- в будущем возможно:
  - новый транспорт (например смс или пуш уведомления) - можно предусмотреть легкую замену транспорта доставки внедрением зависимости с общим интерфейсом (это уже ООП)
  - брокер сообщений прикрутим - можно предусмотреть легкую замену очереди на брокер сообщений (это уже ООП). при этом мы лекго сможем работать в несколько потоков (распараллелить отправку)
  - возможно придется распараллелить отправку и без брокера сообщений, тогда нужно добавить еще поле со статусом обработки задания в таблицу очереди на отправку (новый/в обработке/обработан/ошибка). Либо предусмотреть другой механизм для отслеживания заданий на отправку, которые уже обрабатываются другим потоком (например еще одна таблица)
  - воркер для мониторинга (и алертинга) состояния сервиса отправки (например если много сообщений не отправилось), либо можно заменить на мониторинг через предназначенные для этого инструменты вроде прометеус / графана




# архитектура итогового приложения
- так как есть необходимость валидации емейлов пользователей, то этим будет заниматься отдельный крон таск (CronTaskCheckEmail.php)
- будем делать очереди при помощи таблицы в БД, причем даже если и был бы брокер сообщений, то сохранять в БД информацию по отправленным емейлам тоже было бы полезно
- раз есть очередь, то должен быть воркер, который ее наполняет (CronTaskQueueForSendEmailFill.php)
- а также воркер, который ее разбирает (CronTaskQueueForSendEmailPrepare.php)
- структура таблицы очереди на отправку сообщений
  - id (int, autoincrement)
  - email (varchar, not null)
  - error_count (int, not null, default=0)
  - message (varchar, not null)
  - status (char, not null, default=new) + индекс на это поле
  - date_create (timestamp, not null, default=current timestamp())
  - date_update (timestamp, null)
- замечания по структуре таблицы с пользователями
  - стоит добавить поле id (int, autoincrement) с первичным ключом в таблицу с юзерами (могут быть проблемы при репликации без первичного ключа, да и поиск по ПК ключу идет почти мгновенно при обновлении, а обновлять нам придется)
  - поле validts слишком уникально, индекс вешать на него нет особого смысла
  - поэтому думаю стоит добавить поле valid_date (date) где будем хранить дату в формате YYYY-MM-DD до которой валиден ключ (потребуется заполнить это поле, на основе поля validts и обновлять их нужно совместно, либо вообще отказаться от поля validts в пользу valid_date)
  - добавить ключ по полю valid_date - это даст нам быстрый поиск по таблице в формате "найти записи где дата от и до"
  - добавить составной ключ по полям confirmed + checked для ускорения поиска








